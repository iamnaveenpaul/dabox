---
title: How to Break Into the Tech Industry—a Guide to Job Hunting and Tech Interviews
image: "/assets/default-social-image.png"
categories: Technical-interview
---

My first role as a software engineer in a job search has recently been finished.

Despite learning on how to code almost a year ago, I was able to make a total of 8 offers including Google, Uber, Yelp and Airbnb (for which I eventually joined), after getting English major and was a former professional poker player. I'll describe my advice to a job-seeker in this three-part blog post who trying to break into the technology industry.

First, several caveats.

I have a strange background, but don't make a mistake, I worked hard and got lucky. Before I earned my job offers, I worked as a teacher and Marketing Manager at App Academy, and learned (and taught) this subject for a little under a year.

With that in mind, some people interpreted this as a sort of "get rich fast." It is not. It's more like a "go to a cave six months and probably get a position when you come up." A small, yet noticeable distinction.

Be aware that my advice here is based not only on my own experience, but also on the advice of many others. It also comes from looking into the technology sector of study with 200 or more participants at the App Academy.

That being said, take a pinch of salt to all my advice. When you consider any portion of my opinion that is completely inaccurate or contrary to others, stick to your own opinion. There are many more successful people out there than I do and who know a lot more about this subject.

I've been joining the technology to [make and provide](https://en.wikipedia.org/wiki/Earning_to_give) money. I hope I will encourage and enable others to do the same in providing this advice.

I have split this into three parts: getting interviews, the interview process and negotiation. This post covers the first two parts and in a subsequent post I will finish with much advice on the negotiation process.

Do note that this guidance would focus primarily on the Bay Area software engineering industry. Nevertheless, a lot of my advice here would usually apply to other fields as well. Just replace the field content yourself when I mention "engineering." The mechanisms that underlie is essentially the same though, although the specifics may be unique.

I assume that in your own job search you consider this article useful.

**Part 1: Job Hunting**

* Networking
* Informational Interviewing
* Getting the Chain Started
* Resumes
* Job Platforms
* Mass Applying
* Company Size
* Study, study, study
* General Study Strategy
* Programming Interview Study Guide
* Interview Circuit Training
* Staying the Path
* Mindset
* Your Number Keep Having Fun

**Part 2: The Interview Process**

* The Basics
* Talking About Yourself
* How to Approach an Interview Problem
* Correcting your Interviewer
* Writing Code
* Assorted Heuristics
* Grill Your Interviewers
* Be Excited

**Part 1: Job Hunting**

Job hunting is a number game, first and foremost. You need to believe the numbers.

What if I mention that you have a 4% chance of receiving an offer from any company, this may seem extremely weak. Mathematically, though, it implies that 50 such applications provide an 87% chance of receiving a total of one job offer.

Yet almost certainly no application will become the one that turns into an offer.

This is all right, expect that momentum. But you probably should expect the company that gives you an offer to look like a long shot. Because almost every app looks like a long shot, it's odd and anti-intuitive.

You should be relaxed. Have confidence in large number game laws.

This is valid of networking, direct software, including on-site and on-screens.

**Networking**

The greatest potential operation of job offers is likely the networking.

It sounds promising and intimidating. I guarantee that it's pretty straightforward at its core.

Order all the coffee for everyone.

I mean everyone as everyone working at a tech company.

You should meet all the tech people and I mean anybody at all and say “Hey, this is really cool, I try to get a job as a software engineer, desperately, and the thing you do, I don't know a lot about it. I would love to pick and buy coffee from you, and I’ll pick for your mind about it. Are you free around [time] sometime this week?”

Buy people with tons and tons of coffee. Do it religiously and don't be disgraceful. If you can't afford it, I don't care. Go and invite coffee people even if you go broke due to coffee.

I'll tell you if you go broke, in fact I'll finance your coffee dates until you have a great job and can return it to me.

First of all, how will you meet tech people? Go to [meetups](https://meetup.com/). Go to the events in the area,  developers conferences, house parties in the building, search and hunt them down everywhere. (Techies are ordinary people, and are everywhere around you.) Make yourself creative. Message Facebook users, Twitter users. Cold-mail them (persons, not firms). Don't be tiresome and creepy, but it's all right to reach out online to people out of the blue and to ask them if you can buy coffee.

Above all, sow the seeds and plumb the network. Oddly enough, you have friends or friends of those who already work with tech companies. You just don't pay attention.

Okay.

So now, all of these random people working for technology companies have a bunch of dates. Some might be engineers, managers, operations, designers, customer service providers and salespeople. Does not matter. Meet anybody and everybody.

It's time for an informational interview once you have sat down for coffee.

**Informational Interviewing**

Here’s what you do next

First, learn all about this person, all that you can. Read all about their company. Learn all about the industry or the technology with which they work.

Remember that I did not say "ask for a job." You don't want to get a job. This is all everything except for a job.
Get to know them! Get to learn them! Get to know their business! Read more about what they are doing and why. Ask things you really want to know.

You should make them speak most of the time, otherwise you do it incorrectly. Listen and ask questions more than you talk.

Often they will be intrigued and want to know what you are doing if you wait long enough. Tell them your story. Tell them who you are and why you want to work as a software engineer, what got you here?

Go to the closing at the end of the chat, which typically doesn't require demanding an interview or job referral, unless it is raised by them. Then, ask: "Who else do you know a good person whom I can speak with?" Tell them you like to find out more about the development of the front end, cryptography, or iOS, or anything you asked them about.

You asked them questions, right?

When they can't think of anyone moving over you, inquire when any of the other developers you can speak to care about. Or anybody you are interested in, who works for another tech industry. Regardless of which it is, get in contact with more people. At least one more touch will result in each interaction.

Then just continue to follow the line. Set up more dates for coffee, ask more questions, get more information. All this without unwanted job references. Go through it all.

You might be curious why does this work?

The answer is simple, that fails because when you ask them for a job, they hate this request.

Give you a job? What is the reason? They don't know you. Why will they try to give you a job? Why are they going to waste their time on you?

The power of information interviewing is that you do it about them instead of making it about you. People enjoy thinking and talking about themselves. They enjoy teaching others. They want to be of assistance of any kind, or they want to help others, But the last thing they want is to be harassed for favors by outsiders.

People on the other hand, see your curiosity and genuineness if you continue to do that. They are going to believe your story and they're going to want to talk about you. They will somehow want to refer you. They won’t force people to recommend you. You are making them want them to do so — or, at least, become a partner in your journey.

The truth is, most people can't refer you. This is because their company might be too small to recruit young devs, or they might not need people with your skillset or because they may have over-hired for the quarter or, believe this or not, they may have been secretly failing as a business and might have no money.

That’s okay. Have patience and move on with what you’re doing.

Somebody will inevitably float the idea (if you do this enough): "I will refer you if you want."

When they suggest so, please ask if they’re comfortable to do so. Then they're going to say yes. Say 'holy moses, that would be great,' and keep in contact with them, appreciate them, provide them the curriculum vitae. Congratulations, you just got a reference yourself.

Look at it? It's not been that complicated.

Now keep them updated about your progress through the pipeline of their referred business. Do not hesitate to ask for further specific guidance.

Oh, and ask them for more contacts before you leave that coffee date. I mean that. No one can stop the chain.

**Getting the Chain Started**

How are you going to begin the chain?

You're likely to have connections in the tech industry already. Even if you don't think so, you still have it. Go check your Twitter, Instagram, ask your family, chat in high school to people you knew. There's nothing off limits.

Build a table/spreadsheet of each individual person you know who is working for a tech company. Label the company for which they are working and what their role is in the business.

Then sort by business, and then by position, in all your contacts you could find. At each company on your list you must meet the most important contact (an engineer is more significant than someone in operations, etc.).

**Reach out to every single one**

Invite them for coffee, lunch or dinner. Always buy all the time. Plant them for additional connections and referrals. This is probably the most powerful lead source for you if you have a strong network.

The purpose is fantastic, because references are of greater importance than rough applications unless you have a stellar resume, which I believe you don't because you are bothering to read this guide. For top companies this is particularly true.

And maintain a healthy funnel. Keep scheduling coffee times. Maintain networking, even if you're in the job search halfway. I never ceased to meet people until I had about four offers, and even then at new enterprises I was still interested in reaching people.

**Resumes and Cover Letter**

There is so much to say and it's so personal to your background and experience that I am not going to offer here much specific advice. Scour for information on the [web](https://jsonresume.org/schema/). I would highly advise someone who knows what they are doing to have your resume checked.

For short version resume, still preserve your one page curriculum vitae. Highlight any mathematical or technological aspect. Do not simply describe your obligations, calculate everything in terms of effect. Make your resume nice, particularly if you claim to be a full-stack or a front-end developer. Don't use Times New Roman or Arial. A little design effort which could go a long path. Never have the [typos](http://blog.alinelerner.com/lessons-from-a-years-worth-of-hiring-data/).

Many people do not read cover letters. You usually have to write one and you will probably end up with an adjusted script. Personalize them always— try to find a reason why you like the mission of the company or find its work interesting. Keep it short and make the craft to a minimum. There is no shortage on the internet for cover letter advice if you need more advice.

**Job Platforms**

Get all the platforms for recruitment. The first job offers I received were from [TripleByte](https://triplebyte.com/), which I cannot highly recommend for software engineers.

Therefore, set up an [AngelList](https://angel.co/) profile, [WhiteTruffle](https://www.whitetruffle.com/), [SmartHires](https://www.smarthires.io/) and everything else. Apply to [Hired](https://hired.com/). Clean up your profiles LinkedIn and Github. Get README'd and preety for your projects.

Even if some of the platforms reject you or you don't get hits, the time you can spend is a big return on investment.

**Mass Applying**

Links and work networks are obviously more effective approaches, but raw applications should not be ignored. This is especially true when you have a strong resume, because your response rate is likely to be higher. Raw applications are low investments so you can pump them out and optimize the number of potential bites within your free time. They're also the main way I saw most students from App Academy get jobs. But more volume is required.

I suggest that most people mix with their approach in some size.

You should make sure that you pre-commit to many companies per day.

Large requests for companies are completely needless. You lose focus quickly. Structure your time and set your own goals. Respond in 45-minute sprints with applying to batches of companies. Using Pomodoros to be responsible and correct.

**Company Size**

From my experience, it is more probable that SMEs have a chance to make a blunt demand.

Big and prominent businesses are more prone to have strict ratings and to throw away their programs if they're not made of thrilling words such as the 'Stanford PhD' and 'literally, a superhero.'

Minor firms are hit-or-miss.

Fire at unsexy businesses. You will get an interview much more often, and it's ultimately important to get an interview under your belt at this point.

Understand that it's much more than where your first bid comes from. Even if you're not happy about the deal from a client you can use it quickly for a business that you want more. More on this later when negotiation is discussed.

**Study, study, study**

This may be the most important part and a great deal of anticipation flows in. Study your ass off. Your study habits are one of the main determinants of your interview performance, not to mention your work performance.

In this zone, you are trying to break, so break in!

Below, I'll recommend someone to play a role as a full-stack developer or back-end developer. You can look for more specific advice on these fields if you want a career that is evolving in front-end, game development or embedded systems, or something that is sufficiently advanced.

This is the training I used once. The understanding of success management and the philosophy of education has influenced my approach to research. Your miles can vary, however.

I'm supposing you already know how to program. If you don't, read [this](https://haseebq.com/cracking-the-coding-bootcamp-the-definitive-guide/) as a first step instead.

I should also mention that the above guidance was geared for bigger, more established corporations interviews. In smaller firms, the abstract problem of your interview is less likely. You might need to do pure programming drills, patch a flaw in your production code, or create a small semi-practical program. You will also be asked questions about certain languages or frameworks more likely. Some of those interviews were conducted, but only at smaller firms. Adapt the course accordingly.

* A sure disclaimer that "Programming interviews are broken". I agree with the common refrain in technology. I assume that traditional tech interviews are poor software technology skills predictors. Yet I crafted this advice as a backdrop to the regular software interview, just like any successful hacker. Take it, and don't take it for what it is.

**General Study Strategy**

Next, a route map of a high level.

Watch [this](https://www.coursera.org/course/algs4partI) (Princeton Coursera algorithm course by Robert Sedgewick), primarily up to and beyond Dijkstra's algorithm. Try to keep hold and script as you go. You don't have to introduce things in Java if you learn It already.

Read [this](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/ref=sr_1_1?ie=UTF8&qid=1462241467&sr=8-1&keywords=algorithm+design+manual+skiena&tag=charity48-20), The Algorithm Design Manual on general algorithms and context data structures. Move through most of it, the massive appendix can be skipped on specific algorithmic subjects.

Buy [Cracking the Coding Interview](https://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/ref=sr_1_1?ie=UTF8&qid=1462241515&sr=8-1&keywords=cracking+the+coding+interview&tag=charity48-20). We’ll use it as a repository for coding problems and solutions.

Podcasts such as [Software Engineering Daily](http://softwareengineeringdaily.com/category/podcast/) and The [Bike Shed](http://bikeshed.fm/) could also be heard regularly. Read news from Hacker. You don't understand a lot of things, but that's all right. Only breathe it in. Just sink up. This will over time provide you with some insight into modern web stacks, current trends and styles in which developers talk.

I recommend reading through [HiredInTech](http://www.hiredintech.com/system-design) or reviewing a lot of the highest blog posts on [High Scalability](http://highscalability.com/all-time-favorites/) while writing to device design and architecture. There is also an immense list of [Github repo of resources](https://github.com/checkcheckzz/system-design-interview) and also other tools for system design interviews that you can directly search for.

Do your practicing in whatever programming language you know best, if you already learn the programming language. It's not going to care for the interviewer. If you have a choice from different languages, you would like to have expressive languages such as Ruby, JavaScript, Python, etc. Then, when we will talk about the interview advice.

Object-oriented design and code organization are main topics and will be discussed in interviews. Sadly, there is almost nothing else to learn than to write down a lot of well-structured programs, and receive criticisms and review code.

If you have no experience in programming, then it is a good location for a software bootcamp to help you to a great extent. You will be able to write applications and be praised for your programming design. But the always online communities such as [Stack Exchange](https://codereview.stackexchange.com/) offer options for you.

If a concept in a book or on the Wikipedia is hard to understand, look at YouTube videos of persons explaining it in various ways. This technique I found to be incredibly efficient.

Ask people for help when you struggle. When you meet no one, get into StackOverflow and find the language you're operating in with a strong IRC stream. Be a burden to others, question quickly and shamelessly. You've got my approval.

You don't have to spend more than a 20-30 minutes without progress when you are working on a problem with algorithms (for example, in CTCI) even if you won’t get it. Take a look at the answer. Unlike popular belief, spending more than 30 minutes is unprofitable.

Many people are not going to approve with what I’ve said.

Screw those people.

Nevertheless, when you find the answer to more than 2/3 of the problems too difficult to fix, those are too difficult for you and you must downgrade.

Nonetheless, it's a waste of time banging your head against a wall or staring at the code blankly. You want to optimize the amount of training per hour while working with code / algorithms.

Whenever you look for the answer to a problem with coding, try to understand it. Take a debugger, if it is confusing and mysterious particularly. Find some explanations it functions.

And now this is extremely important, if you have not solved the problem yourself, treat it as if you have not solved it at all. Add it to the question cycle. Mark it as something from scratch you have to try again. Pause for at least one day, then try to find a fresh answer. Rinse and repeat again and again, if you struggle.

Eventually, find the training nightmare more structurable. Make an appointment. Know exactly when you will operate on that, when you will take breaks, when you will go to lunch and so on. Allow the life more versatile, however simple expectations are as to how many hours you spend training a day.

Most of my study advice is general and this is the study guide that I would advise.

**Programming Interview Study Guide**

Function in the Princeton algorithms first and foremost. You will obey it as far as practicable and enforce it. All these important data models are also incorporated along the way. Many of these are not discussed in the curriculum explicitly, simply apply them.

* Linked List
* [Dynamic array](https://en.wikipedia.org/wiki/Dynamic_array), implemented with a [ring buffer](https://en.wikipedia.org/wiki/Circular_buffer) (use a statically sized array underneath the hood)
* Hash set
* [Hash map](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists) (with chaining)
* Binary heap (without decrease-key; know that [Fibonacci heaps](https://en.wikipedia.org/wiki/Fibonacci_heap) exist and know their guarantees)
* Binary search tree (doesn’t need to be self-balancing; know that [self-balancing trees](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree#Implementations) exist and know their guarantees)
* Prefix tree (a.k.a. trie)
* Suffix tree (don’t worry about compression, just build a dumb version; know that [Ukkonen’s algorithm](https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm) exists and learn its guarantees)
* An object-oriented [adjacency list](https://en.wikipedia.org/wiki/Adjacency_list) for graphs

Know the dynamics of its basic activities all the way. This helps to show them creatively. Watch the images. On paper/whiteboard, print them out.

Once all these have been removed, introduce the most popular algorithms in this subset:

* Binary search (implement it both iteratively and recursively)
* Randomized quicksort (pay extra attention to the partition subroutine, as it’s useful in a lot of places)
* Mergesort
* Breadth-first search in a graph
* Depth-first search in a graph (augment it to detect cycles)
* Tree traversals (pre-order, in-order, post-order)
* Topological sort (using [Tarjan’s algorithm](https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search))
* Dijkstra’s algorithm ([without decrease-key](https://stackoverflow.com/questions/9255620/why-does-dijkstras-algorithm-use-decrease-key)
* Longest common subsequence (using dynamic programming with matrices)
* Knapsack problem (also dynamic programming)

Know all these algorithms time complications and spatial complexities ([cheat-sheet](http://bigocheatsheet.com/)). Know the difference between [amortized, average](https://stackoverflow.com/a/7335098), period assurances that are depreciated, good and worse case time guarantees in situation.

Make at least one or two issues where a matrix is used for BFS and DFS.

After these are finished, the algorithms and the data structures need to be properly founded. Read the entire Development Manual for Algorithms to improve your comprehension. Implement something you find interesting enough.

Few points of interest, don't bother programming, but read about heap type. Know that the storage is O(1), though, because of cache inefficiency basically quite gradually. Read among easy and medium-sized intermediaries. If you like, script them.

Learn the fundamentals of bit manipulation. Could clarify what AND, OR and XOR are doing. Know what is an integer signed. Know that in one byte there are 8 bits. Know what the mount from a high standard is and get a feel for the basic operations of the hardware. [This](https://www.youtube.com/watch?v=RZUDEaLa5Nw) great video about the internal functioning of the original Game Boy covers almost everything you need to know.

Learn more. Learn how to develop a schema for the SQL database; often interviewed. Read about ACID, the CAP theorem and BASE (you don't have to memorize the terms; you only have to understand concepts to a high level). Understand why joins can be invalid or unscalable. Know the [NoSQL database](https://www.youtube.com/watch?v=qI_g07C_Q5I) basics.

Read about the value of caching and caching and its efficiency. Know what a miss is about a cache. Know that reading from registers is fast, it reads quite quickly from the different caches, it is slow to read from memory and it is abysmally slow to read from the hard disk.

Read how to deploy a LRU cache and write it down in a worst-case time O(1). This is a strangely common problem in the interview.

[Learn](http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/comment-page-3/) what happens to your browser by entering a URL and pressing Enter. Discuss regarding DNS queries, the request-response process, HTTP verbs, TCP vs UDP and how cookies function, be handy. During interviews, it appears all the way.

Learn how to speed up a slow website in standard terms. It covers several different things, such as introducing server metrics for optimizing popular queries, enhancing caching, loading front end resources from a CDN, zombie listeners, etc. Also a great, sweet rabbit holey interview.

Obviously, these last two are specific to web development.

You now have most of the grounding you need when you have covered them. The preparation on the interview should be available for you.

I would probably start here, if you already have a background in CS.

**Interview Circuit Training**

First, work on the first three issues for each relevant Cracking the Coding Interview section. (If you don't know these languages, skip testing and skip concurrency, you'd skip the sections like Java or C++ unless you have experience writing programs, but read about it.

Write down your solutions in code. Ensure that they are working. Verify the case of edge.

Stop coding each and every solution after you have written a good 30 + solutions. You should now have some solid coding practice and develop your high-level intuition about how to best address a problem. The rest is pattern recognition.

The rest of the coding interview continues to be worked on. But from here on, just write a high level algorithm description you would use to solve the problem instead of actually writing code.
 
Here is an example of what I mean: "For each subsequent query, sort out the array first, then search the array again and again. This should be pre-processed by nlog(n) and log(n) for every query.

Check for a solution in the book after you have written your high-level solution. Write a description of the perfect solution if your solution is unsatisfactory. Make sure it's important to you. If it doesn't make sense even slightly and you don't know you can write code, code it, try edge cases, etc.

You should only encrypt a small percentage of the other problems with this workflow. You ought to be able to overcome many more problems every day.

Make sure you collect your solutions in files so you can easily review them. The question statement with any approach you have written or defined should also be included in your solution files.

Whenever you look at them (which should be updated weekly), you can test this: read the question statement first, determine how the problem will be resolved in your mind and then search for the algorithm you have written. Again, reaffirm why the right answer is right.

Once the entire book is complete, spend the rest of your studies on [LeetCode](https://leetcode.com/) to make problems.

LeetCode is an interactive programming platform that helps you to write code against test cases, such as HackerRank and CodeWars
I particularly recommend LeetCode as it has the most reliable problem set I saw for many algorithms. It also has a great feature that tags companies in which the problem was asked to tag programming problems. (If the company employs less than 2000, it will not probably be listed anywhere.)

Thus, you can do every single problem that the organization has on LeetCode each time you have an interview with a large company. To see the tags, you need to pay for a subscription, but it is worth it.

GlassDoor is also an excellent source of company-specific grinding problems. (You can try CareerCup as well, but its precision is somewhat more uncertain.)

After all, the more item remains lacking, the actual practice of Interviewing. Practice as performance is a key principle of learning. Consider the way you work as close as possible to your actual performance. In this scenario, the actual performance appears before a whiteboard and is questioned orally.

Practice it.

Ask somebody before a Whiteboard to create a mock interview with you (and then reciprocate). Let them put questions to you that you never saw before. Practice all your skills, including presentation, clarification of the problem, jokes, anything you plan to do in a true interview. Treat it as if it's the actual interview. Be ready to fight and look dumb. Don't let the character break.

This is also the only way architectural interviews can be done. Ask your interviewee about the application response cycle or about how you could architect Twitter or other favorites for standard interviews.

A great resource is [interviewing.io](http://interviewing.io/), so you can get interviewed and interview other people anonymously and practice problems in programming. Right now they're in private beta, but look out.

You should become an algorithm beast in a few months if you actually do any part of this workflow. Your outcome in an interview will be equivalent to the average CS degree, even if you are not superior in coding skills.

Nothing about this is magical. Everything's just learning. Everything you need for a coding interview is available freely. You have to take the time to do that.

Okay.

Now, in algorithms you are clearly fantastic, so let's move on.

**Staying the Path**

Searching for a job is hard. You'll get many, many rejections as soon as you start submitting for firms.

It is profoundly demoralizing to fight for months and be denied everywhere.

It will seem like it;s your fault. It'll sound like you have something wrong going on with.

Just like that my job search started. The same applies to many people who have found fantastic jobs. Nearly everybody is going through it.

I like sharing a few stories with students of the App Academy.

I once interacted with a student at the App Academy that was not a graduate. He had spent eleven months searching and had submitted hundreds of requests. He was absolutely willing to give up finding a job. But he could get his first offer from a startup with some support and coaching. After some negotiations, this offer was the second highest offer ever received by any student in the history of App Academy.

Another student with whom I worked had the same story. Upon hundreds of applications 11 months of nothing but refusals. He finally received his first and only bid after he obtained only offer from Uber. There he still plays.

This story's morale here is: hang in. Continue to grind. Recall, this is a game of numbers. Continue to put yourself out, and above all, keep caring for yourself.

It's necessary the simple thing. It sounds stupid so focus on self-care in the job search before anything else.

Do something that distresses you, whether it's therapy, showers, video games, something. Spend time with friends. Spend time with friends. Eat real  food, good food.

Make sure how you rest. The extended hours of sleep is usually greater than the later hour of work.

Have regular exercise, even if you don't want to and dislike it all. Innumerable experiments showed that exercise was basically a panacea. This increases personal wellbeing, like anti-depressants, more than any other clinical technique.

You're going to be sad.

Notice it is there if it does. Speak about it to others. Don't be disgraced. Fight it out actively. The partners are meditation and vitamin D, spend time outside in the sunshine. If you need a professional, see a doctor.

Your best defense, though, is to plan your time. Plan your schedule religiously. Learn what you're going to do everyday.
Liberty is your enemy in many ways. Let your shelter be structure.

**Mindset**

I used to work with professional poker players as a psychological trainer as well as other people in high stakes. Much of this work has informed my work search approach.

This is my attitude suggestion.

Take everything as a learning experience first and foremost. That is, never go to a phone screen or an interview on site in the hope of finding jobs. Don't wish at all for it. Just go and learn, mess up, try and see what all this interviewing thing is all about.

Almost I would say think as someone else was asked to this interview and you're just their doppleganger. You get to be  a fly on the wall, try things out, but it doesn't matter if you're working it out or not. Just because it's fun, you're doing it. Why can't you get more interviewing experience?

Do this for every interview. Stop looking after the outcome. Just go inside and learn. Don't hope to be hired at all.

The influence on you as a candidate will be enormously beneficial. You're not going to be so anxious and scared. If you don't get the work, you're less tied to the outcome and will not be devastated. And it makes the whole system more enjoyable so simpler to actually benefit from it. Normally, a guy rarely offers his first few interviews, so you should anticipate this.

The second major recommendation is to give yourself targets on a continuous basis. However, just set goals which you are fully aware of and in your control.

A goal such as, for example, "I want to get a job by 20 January" is a terrible objective. This isn't yours. How do you ever know if you are progressing in this direction? Before that, you'll have a job or you'll not have one.

Choose your own behavior objectives instead. You could completely control and calculate a target like 'I want to apply for 4 work every week,' or' I want to invite 4 people for coffee dates a week.'

The third and final suggestion is how to plan the job search. I used to tell my students, here's a little parable.

**Your Number**

Say there's a number somewhere in the archives (databases) of God. That's the number of days until you find a job you will have to work off your ass.

Everyone in God's server has their own set. You too.

Let's say N, that number marker.

You look for decrements the N by 1. Seriously searching for a job every day. Naturally, you don't know what N is. And until you finally receive your first bid, you'll never understand what N is. (Assume God is [sanitizing SQL injections](https://xkcd.com/327/) into his input.)

You can't pick your N. Several factors have an impact on the scale of your N— your background, training, networking, structural biases and randomness. A random shitload, in fact.

Others will have fewer Ns than you, although they are not as eligible or skilled as you are. That is all right.

Ignore Other people. They've got it easier, and it's OK. But your N is determined already, and it's your only job to whip that N.

Treat it like progress every day. It doesn't matter whether you are rejected by an enterprise, if you screw up an interview, if it's unexplained or inexplicably lowballed. It decreases, lowers and lowers while your interview skills improves, gets better and better. Be trustful. You get closer.

It is improvement every day.

And, last but not least...

**Keep Having Fun**

That's important, really.

Continue to do things. Continue to work on projects. Find stuff you're curious about. Learn new technologies, frameworks, languages and algorithms. When someone tells you, "What's your last job?"You ought to have a good reply, the one that excites you.

Function on things that is enjoyable. You're going to be bright, inspired and glad.

You're coming into this business because you want to programme, right?

So just keep programming!

**Part 2: The Interview Process**

All right. You have all done Part 1, and interviews have been aligned. Good. Great. What now?

I'll repeat, treat each interview as an opportunity of training. Don’t care whether or not you are going to get the job. You're almost sure to bomb the first few times. It's all right. Check for it and turn it around.

Interviews are a point for skill, not a mystical ability. The more you do this and the more you analyze your errors intentionally, the better you do it.

Don't hesitate to get a job. Don't think. Perhaps not every interview would contribute to a position. That's all right. Learn and have a great time. That way, you're going to do much better at it.

**The Basics**

So you're up to your interview.

If you are particularly uncertain as to anything, you can ask your employer or the company's point of contact. You could ask them stuff like: what kind of problems is the interview going to be? I ought to look at anything specific? Can I use Python, can I use that? Is pair programming going to be there? Do I have to bring my own coding laptop? May I access reports from Google during the interview?

All of these are fine issues. When you tell, nobody's going to care at all. Over topics like these, I saw many people agonizing over questions, but never ask.

Some basics:

Dress nicely but casual at a tech startup in the Area. All fits well like a sweater and button-up, or jeans. Wear a shirt and slacks in more mainstream sectors. Ask your recruiter if you don't know. It's by no means a taboo thing.

They will often offer you a drink. If you want, take it. Use their washroom. Do everything you can to calm. You should make yourself comfortable.

Say hello, introduce yourself, when you meet your interviewer. Relax. Try to remember their name (not a big deal if you don't).

Your interviewer will walk into the room. Smile. Tell her your name. Confidently shake the hands. Look in her eye.

Adopt the language of relaxed body. Lean back in your chair. Don't trick your hands, just tie them together if you can't help them.

You're absolutely alright. Anyway, this interview is for practice only. Don't evaluate yourself. Do not examine yourself. It's not odd that your arms behave so messy.

Just tell the investigator about her team and how she worked lately. The dialog will stream in.

If you're worried and nervous, it's all right to say that to them. It's also all right to say, if you're eager to start.

**Talking About Yourself**

* Most computer interviews are surprisingly formulary when it comes to talking about yourself.
* Why us?
* Two of those two are permutations to almost every query that you will be asked:
* What's your story, why would you leave your last job, Walk me through your resume? (These concerns are essentially the same)
* Ask me about your tough problem or challenging bug you have faced, How you fixed it. Tell me about it!
* Tell me a wonderful idea or interesting project on which you have been worked on.

The first problem is especially important. They want your personal story to be told, basically. Your response will have a strong impact on their interpretation.

It's more just about telling a story. Take the protagonist in a tale and plan it with a beginning, a middle and a finish. Inflexible points, characteristics and motivations that should be easy to understand. Make as short as it can be and preserve color and what's interesting for you. You don't want to be evil. Construct your tale with obstacles, and you want to change yourself instead of refusing or disliking things.

You're going to tell this story over and over. If you meet sufficiently, it will finally become a story. The best way to improve it is to practice it loudly and read it, record and listen to it, literally. Try to get feedback from someone you trust and ask them to be as cruel as possible for criticism.

You should have predetermined answers to the remaining three questions. When you forget focus, it can help to sit and discuss every relevant story you can (for instance, any issue that you know that you're worked and solved on), and then expand it from a bigger list.

This is difficult to practice successfully in a vacuum, but collaborating with someone else is a good thing.

Once you address all the soft questions of your interviewer, they can ask you whether you have any questions. Tell them until the end of the interview you will save your questions. This gives you more time to evaluate the actual programming part which is most of the time.

Let us now examine advice for the current interview on programming. This will be very unique for whiteboarding, but many of the guidance is also relevant to computer programming.

**How to Approach an Interview Problem**

Always repeat the question in your own terms before addressing every (non-trivial) question. Be sure that you understand what they are looking for precisely.

Attend that you misunderstand what you are demanding (expect 10 percent of the time you will misunderstand what exactly they are asking). If that is the case, they will clarify if you repeat the question. But you will not correct you for a while if you fail to understand or jump straight into working on the wrong problem.

This is because the supervisor typically suspects that you are inept when you start performing activities that are pointless.

This is all right. The interview is complicated because most people are inexperienced and questioning incompetent people is their task.

So if they see you do something stupid at the beginning, then they won't assume charitably that you're an intelligent person with a bad day. That's all right; over the duration of the meeting, you can slowly appear to be credible. Nonetheless, this initial variable is important to be aware of.

Therefore, all of your communication should be as explicit as possible. Identify things in nauseous detail. This will remove any misunderstandings between you and your client and reassure them that you are not inept. That's incredibly important.
Let's push ahead. All right.

I almost always begin to work on a small, medium sized example on the whiteboard for any non-trivial issue. This once again reinforces my understanding of the problem and my instincts for overcoming it. It is equally worthwhile tossing yourself a grasp of why the issue is daunting here in some situations.

Don't switch to code ever, immediately. Do not jump straight to coding, even if you think you know the answer. Explain first in the abstract strategy. If your strategy has flaws, the interviewer sometimes points them out; the interviewer is more willing to let you hang yourself by jumping straight in.

Now once you start to work through this problem mentally, try to talk. Do not stop moving your mouth. Make every effort to let the investigator understand what you always are thinking. Whatever the step you take in, however your mind is low, foolish, or unsure, just say out loud. So share the outcomes of your analysis, even if it was fruitless. If you need time to think, tell them “give me a moment to think about this."

Engineering interviews do as much with communication and reasoning as that with results. An interview on communication alone is absolutely possible, even if you do not get the optimal results.

Look at your interviewer. Engage with them. Ask questions. Make a joke. Don't ever ask for assistance or help. And don't give up.
Never, ever give up. You don't give up on yourself as long as they don't give up on you. Keep pushing, try different things and explain why all that you can think of isn't working in every case.

If you follow this advice, you will have much more assistance, more leeway, and more empathy from your interviewer.

If you do not have an efficient solution, go ahead and explain the answer of brute force to the problem. If you enumerate a correct but inefficient solution, you will almost always be honored for something. You don't actually have to code it (depends on whether you are asked). It is usually sufficient to simply describe how it operates. Think and say, "It solves the problem exponentially. It certainly isn't perfect, though. Let me see if I can find a more efficient approach." It also helps you tackle the problem and gives you a glimpse into how it can be solved effectively.

You are curious what the algorithm your brain uses to solve this issue, if you want to solve it by hand? It's good for finding a Brute Force Answer by being a good heuristic.

Don't be frightened to look silly. It's alright to be mistaken. If you don't know what it means, it's fine to ask questions. Take in stride and laugh about it. I botched at least one question in almost all interviews, in which I received an offer. Don't let this ruffle you.
That said, trust your intuition if you think you know something but are not sure 100 percent. Usually you're going to be right. It's all right to be corrected if you're not.

**Correcting your Interviewer**

You may sometimes think that your interviewer is wrong.

Certainly, your interviewer is wrong sometimes. But you'll be the one who's wrong much, much, much more likely. Think of it, You are stressed out and coded for your dear life, while your interviewer sits on a chair and watches the 100th person struggle this year to solve your preferred pet problem.

Defer your interviewer by default and assume you're wrong. Never get upright. Figure out why you are wrong. If, in fact, you are right, you should have the method of proving it.

All right, so you've all talked to death, you're ready for code now. First, say: "Do you want me to put that on the code?" If your interviewer has final concerns about your approach, that gives them a chance to stop you. Sometimes they can also stop when your algorithm is acceptable, but they're looking for a more optimal approach instead.

But they're usually going to say yes. Let us then begin to write code.

**Writing Code**

Just joking. You aren’t ready to code yet.

First, verify verbally your assumptions on the input before you write anything. May I say that I never get a detrimental contribution? May I presume that all are on 64-bit integers? Can I assume that everything is ASCII-encoded in this input string? May I say I've had my data formatted input as a hash map, or other? Can I lift an inappropriate entry? If the input is a float, how should this function be done?

Often the interviewer is pleased with this specificity and helps you to tackle certain mistakes for incorrect outputs. If you don't discuss this, though, then they could tell you later "Oh, but what if you have a negative integer?"Then something must be erased and you must squeeze in a line to handle mistakes and waste more time.

Now you are nearly ready to code. Advertise the dialect that you will publish in (just kidding). But keep that in mind. A language with rich default library, including Ruby or Python, should be strongly preferred to you. Intercept how long it takes you to express the same algorithm when you choose a language like Java or C++. They don't know how hardcore the developer is or what type of programmer you are, they will only see whether you have solved the problem during the time you've allocated it.

Now is the time to mention whether special data structures or libraries are needed. "When I think I have a prefix trees" , is it completely cool? Although you don't learn the language of a prefix tree library. It's all right to declare the API just as you go: "I think this heap has a .pop_min process."

And it's time for coding now.

Start to begin at the board's top left corner. In whiteboarding interviews, erase stuff that's in the way and give the script as much space as you can. Note that leadership of the board is surprisingly important.

More board management advice: Closing the frames (whether curly braces or blocks) early can make things complicated if you have to cram them through odd lines of code or delete them a bunch. Do not remove them before you really get to them.

It's very, very common to add additional lines in a field elsewhere. The more you miss the breathing room, the easier it will be. So, apply plenty of white space around the rows as a standard activity. 

It won't matter most of the time to your interviewer if you don't remember the exact name of a process. Don't mention that. Only come up with a name that's reasonably close to it. When they question what they are doing, just say: "I might be wrong about the title here, but this approach produces a reversed variant of a hash map so the identical values are now referring to their keys". This will please many interviewers.

Descriptively call the parameters, but leave them short. It will suck to constantly write long variable names without autocompleting.

When you compose, derive as much reasoning as you can into actions of helpers. This is an extremely useful technique for whiteboarding.

Only call the support functions as you go and don't feel the need to immediately write their declarations. Simply say: "I will write this function later, but it only returns a hash table mapping each character in the string to its rate."

Go forward and continue to work through your main function, and then think about the helpers. This will keep you going and make learning and thinking about your script simpler.

Once you finish and decide the characteristics of the structure of your primary function, the interviewer will often be sure that you can compose some of the helpers and will not want to see you code them.

Simply say: "This is the role of this aid.. blah blah. Would you like me to write this helper function, too? "When you say yes, go ahead and write out all of it. But at least it gives them the opportunity to say no. Such consistency alone in my interviews ended up saving me a lot of time.

Eventually, test all of the script once you've done. Simply say "okay, let me test this now." Read the script from top to bottom to make sure it makes sense. Watch this as if you had a debugger, following an input's course and transformations. Correct some blatant errors. Instead start checking for edge cases.

Many common edge cases: null/empty data, 0 input or size 0, 1 input or size 1, or redundant information. Attempt to figure out your beliefs and see how they might be broken.

Once you are confident the edge cases are accounted for by your approach, then and only then switch to your interviewer and inform "I think this solves the problem.". Make it loud that you think it’s done.

Now go on with the algorithm study. Announce the difficulty of your solution's time and space. Speak about any tradeoffs that you could make. "If you want to take O(n^3) time, you should memorize all the answers and retrieve them for subsequent questions in O(1) time. But that comes at a great price of space and time up front.

**Assorted Heuristics**

That's kind of dumb, so I figured I'd include it because it seems to be helpful to people.

If during an interview you are blanking, follow these thumb rules that are loosely in order of usefulness:

* Try hash maps.
* If your question falls down to looking for something, try binary checking.
* Try to sort data.
* Could you break the issue into sub-problems? Would addressing the size problem (N–1) makes it easier to answer for length N? If so, consider using functional programming to solve recursively with.
* Try to put them in a prefix tree if you have a lot of strings.
* Each time you need to constantly take a diverse collection's min or max, consider heaps. (Prefer a structured array if you don't have to add random elements.)

Sure, now the conversation is over. Now is the time to ask a feedback or questions from your interviewer. This part is also surprisingly important.

**Grill Your Interviewers**

A famous fallacy throw is "you're questioning them as much as they're questioning you." I'm thinking if that's real, then bring them through the goddamn wringer.

Ask them why they have chosen to join this company, about a moment they have messed up and how it has been treated, what they think the company should improve at. Tell them how they see themselves through in the next few years at this company. Ask them if they'd like someone would have told them them before they entered here. Tell them if they ever thought they'd quit and if they'd go, where they'd go.

To make myself clear, these are not questions usually for company. They're the interviewer's questions.

Among a few factors, I suggest grilling the interviewer:

* Your interviewer is typically representative of the people for whom you will operate if you enter. You will know about the kind of people that work here as much as possible.
* It will give you a lot of insight into the company than any common query.
* This brings the conversation some energy. Instead of being continually on the defensive, you get some time to breathe as the interviewer answers to your concerns by asking tough questions.
* It's more fun as well!

That said, you are likely to have some burning questions that you really want to ask your interviewer, such as "Why did you get into data engineering?" and "What are your thoughts about the transformation of this business to service-oriented architecture?"

Which brings me to my second piece of advice on grilling interviewers.

You're not going to have snappy, precise questions to ask most of the time. You memorize and submit a set of questions over and over again. Not only for different companies— the exact same thing is basically being questioned by consecutive interviewers at the same agency.

Why so?

Because for one, at the close of the interview, interviewers usually ask questions. Until then there is a good chance that you will be exhausted emotionally and that you will not feel like coming up with creative, incisive questions.

Never, ever say, "I don't have any concerns." Be interested

Second, interviewers do not make notes that a nominee told them for issues or asked them these questions. So if you've got a good set of questions, no one at the company knows you've asked the same questions.

Third, they wouldn't matter if they did. Good questions are still good questions, so having the responses to the same good question from different people is valuable. That way, I learned a lot about the complexities of different companies.

**Be Excited**

This is the last thing I want to make, and it relates to the whole cycle of your interview.

Be enthusiastic about interviews. Be excited to learn what your interviewer is doing and the promise of working with them. Be enthusiastic about the company. It's trite, but it makes a big difference. Tell them how much you like the people you've met and you love the culture.

Interviewing is like dating, shockingly. If you're enthusiastic about them, the interviewer will be far more likely to be positive about you. A positive attitude would help them want to interact with you more and even go hit for you when it comes to the time of the decision.

Not only that, but enthusiasm is an indication that you really want to do the role for which they recruit you, and that you're going to work your butt off to do it well. If your interview quality was near the edge, you could end up pushing you over the finish line.

You're undoubtedly going to interview various companies, but you should always think about what makes this business interesting and captivating. If you're not positive, question the interviewees, what makes them love to work here? The reaction can then be reflected back.

You don't want to look desperate at the same moment. I enjoyed using the term "looking for a good match." You want to be fair, but if they give you the best bid, you also want to be winnable. If you seem to be totally disinterested in the business, they probably won't want to make you an offer even if you're passing through their technological bar.

Industries vary greatly in language. But a lot of "style suit" is really just a simple question: do the interviewees really like to be your colleague?

Which completes this guide's sections 1 and 2. The final part of this document will be followed up, concentrating on post-offer bargaining. There is a [live Q&A](https://www.youtube.com/watch?v=1ZO1aqtDiDQ) on CodeMentor where answers to some questions that are specific to the bootcamp experience.

Edit: If you're trying to break into tech and want to earn-to-give (i.e., you're planning to donate at least 20% of your earnings to high-impact charities), get in contact with me and I'd be happy to give you free advice on your resume. :)

Happy coding.